#!/bin/bash

##########################################################################################################
#                                                                                                        #
#     Through this script, you can get the score of your implemented kV storage system                   #
#                                                                                                        #
#     Usage: ./lab3_testing.sh [source_folder] [your_sudo_password] [result_folder] [version]            #
#     Example: ./lab3_testing.sh ./Lab3 XXXXXX ./Lab3 1                                                  # 
#                                                                                                        #
#     Author: Fusheng Lin(2019) Bowei Chen(2020) Zequn Cheng(2021) Haoxiang Pan(2023)                    #
#     																									 #
# 	  Advisor: Guo Chen																					 #
#			                                                                                             #
#     Last Modified Date: 2023/5/8                                                                       #
#                                                                                                        #
##########################################################################################################

# Script body starts here

############################### Start of testing parameter settings ########################################

# The parameters received by the script
LAB3_PATH="$1"
PASSWORD="$2"
LAB3_TEST_RESULT_SAVE_PATH="$3"
VERSION="$4"                       # 1: 2pc, 2: raft

# Coordinator's configuration
COORDINATOR_IP=192.168.66.101
COORDINATOR_PORT=8001

# Leader's configuration
follower_ip=(192.168.66.201\
		     192.168.66.202\
			 192.168.66.203)
follower_port=(8001\
			   8002\
			   8003)
LEADER_IP=${follower_ip[0]}
LEADER_PORT=${follower_port[0]}

# Experimental environment configuration
EXECUTABLE_FILE_NAME=""
NC_TIMEOUT=10
ERROR_RETRY_TIMES=3
START_RETYR_TIMES=$[1 * 5]         # 5 seconds
START_COORDINATOR_ONLY=1
START_COORDINATOR_AND_ALL_PARTICIPANTS=2
START_ONE_DATA_PROCESS_SPCECIFIC=3

# Virtual network card environment configuration
DELAY=100 						   # ms
PACKET_LOSS_RATE=10 			   # percentage

LAB3_ABSOLUTE_PATH=""

# System implementation language code
PYTHON=1                           # PYTHON language
C_OR_CPP=2                         # C/C++ language
JAVA=3                             # JAVA language
UNKNOWN_LANGUAGE=255               # UNKNOWN language
NO_JAR_FILE=101              	   # have no jar file
NO_KVSTORE2PCSYSTEM_PY_FILE=102    # have no kvstore2pcsystem.py

# Function return value global variable definition
set_result=""                      # return value of send_set_command
get_result=""					   # return value of send_get_command
printf -v leader_infomation "(.*):(.*)"

# Result code
SUCCESS=0                    	   # operate successfully
FAIL=255                      	   # operate failed
PASSED=66                          # Test passed value
FAILED=99                          # Test failed value

TEST_RESULT_ARR=("")

############################### End of testing parameter settings ##########################################

############################### Start of testing using function definitions ################################

# Set executable file name
function set_executable_file_name
{
	if [ $VERSION -eq 1 ]
	then
		EXECUTABLE_FILE_NAME="kvstore2pcsystem"
	else
		EXECUTABLE_FILE_NAME="kvstoreraftsystem"
	fi
}

# Obtain the absolute path of the specified path
function get_absolute_path
{
	tmp_path="$1"

	# root_dir="/.*"
	if [[ ${tmp_path:0:1} = "/" ]]
	then
		retval=$tmp_path
		echo $retval
	else
		retval=`readlink -f ${tmp_path}`
		echo $retval
	fi
}

# Configuration files(2pc) generated by test scripts
LAB3_ABSOLUTE_PATH=$(get_absolute_path $LAB3_PATH)
coordinator_config_path=${LAB3_ABSOLUTE_PATH}"/coordinator.conf"
participants_config_path=(${LAB3_ABSOLUTE_PATH}"/participant1.conf" \
	                      ${LAB3_ABSOLUTE_PATH}"/participant2.conf" \
	                      ${LAB3_ABSOLUTE_PATH}"/participant3.conf")

# Configuration files(raft) generated by test scripts
followers_config_path=(${LAB3_ABSOLUTE_PATH}"/follower1.conf" \
	                      ${LAB3_ABSOLUTE_PATH}"/follower2.conf" \
	                      ${LAB3_ABSOLUTE_PATH}"/follower3.conf")

# Generate boot information for the storage system
function generate_config_files
{
	if [ $VERSION -eq 1 ]; then
		echo -e "mode coordinator" > ${coordinator_config_path}
		echo -e	"coordinator_info 192.168.66.101:8001" >> ${coordinator_config_path}
		echo -e "participant_info 192.168.66.201:8002" >> ${coordinator_config_path}
		echo -e	"participant_info 192.168.66.202:8003" >> ${coordinator_config_path}
		echo -e	"participant_info 192.168.66.203:8004" >> ${coordinator_config_path}

		echo -e "mode participant" > ${participants_config_path[0]}
		echo -e	"coordinator_info 192.168.66.101:8001" >> ${participants_config_path[0]}
		echo -e	"participant_info 192.168.66.201:8002" >> ${participants_config_path[0]}

		echo -e "mode participant" > ${participants_config_path[1]}
		echo -e "coordinator_info 192.168.66.101:8001" >> ${participants_config_path[1]}
		echo -e	"participant_info 192.168.66.202:8003" >> ${participants_config_path[1]}

		echo -e "mode participant" > ${participants_config_path[2]}
		echo -e	"coordinator_info 192.168.66.101:8001" >> ${participants_config_path[2]}
		echo -e	"participant_info 192.168.66.203:8004" >> ${participants_config_path[2]}
	else 
		echo -e "follower_info 192.168.66.201:8001" > ${followers_config_path[0]}
		echo -e	"follower_info 192.168.66.202:8002" >> ${followers_config_path[0]}
		echo -e	"follower_info 192.168.66.203:8003" >> ${followers_config_path[0]}

		echo -e "follower_info 192.168.66.202:8002" > ${followers_config_path[1]}
		echo -e	"follower_info 192.168.66.201:8001" >> ${followers_config_path[1]}
		echo -e	"follower_info 192.168.66.203:8003" >> ${followers_config_path[1]}

		echo -e "follower_info 192.168.66.203:8003" > ${followers_config_path[2]}
		echo -e "follower_info 192.168.66.201:8001" >> ${followers_config_path[2]}
		echo -e "follower_info 192.168.66.202:8002" >> ${followers_config_path[2]}
	fi
}

# Clear generated configuration files
function clean_up_config_files
{
	rm -f ${LAB3_ABSOLUTE_PATH}/*.conf
}

# Adding virtual network cards to the testing environment
function add_virtual_nics
{
	echo ${PASSWORD} | sudo -S ifconfig lo:0 192.168.66.101/24
	echo ${PASSWORD} | sudo -S ifconfig lo:1 192.168.66.201/24
	echo ${PASSWORD} | sudo -S ifconfig lo:2 192.168.66.202/24
	echo ${PASSWORD} | sudo -S ifconfig lo:3 192.168.66.203/24
}

# Clear virtual network cards created in the testing environment
function remove_virtual_nics
{
	echo ${PASSWORD} | sudo -S ifconfig lo:0 down
	echo ${PASSWORD} | sudo -S ifconfig lo:1 down
	echo ${PASSWORD} | sudo -S ifconfig lo:2 down
	echo ${PASSWORD} | sudo -S ifconfig lo:3 down
}

# Set the specified transmission delay for each virtual network card
function set_virtual_nics_delay
{
	echo ${PASSWORD} | sudo -S tc qdisc add dev lo:0 root netem delay ${DELAY}ms
	echo ${PASSWORD} | sudo -S tc qdisc add dev lo:1 root netem delay ${DELAY}ms
	echo ${PASSWORD} | sudo -S tc qdisc add dev lo:2 root netem delay ${DELAY}ms
	echo ${PASSWORD} | sudo -S tc qdisc add dev lo:3 root netem delay ${DELAY}ms
}

# Set the specified packet loss rate for each virtual network card
function set_virtual_nics_packet_loss
{
	echo ${PASSWORD} | sudo -S tc qdisc add dev lo:0 root netem loss ${PACKET_LOSS_RATE}%
	echo ${PASSWORD} | sudo -S tc qdisc add dev lo:1 root netem loss ${PACKET_LOSS_RATE}%
	echo ${PASSWORD} | sudo -S tc qdisc add dev lo:2 root netem loss ${PACKET_LOSS_RATE}%
	echo ${PASSWORD} | sudo -S tc qdisc add dev lo:3 root netem loss ${PACKET_LOSS_RATE}%
}

# Check if Netcat is installed
function check_netcat
{
	echo ${PASSWORD} | sudo -S apt install netcat
}

# Configure the startup function for the testing environment
function init_network_env
{
	check_netcat
	add_virtual_nics
	set_virtual_nics_delay
	set_virtual_nics_packet_loss
}

# Compile project production executable files
function do_make
{
	echo -e "\e[32m【tester】：Start make, waiting for a while......\e[0m"
	make -C ${LAB3_ABSOLUTE_PATH}/
	retval=$?

	if [ $retval -eq 0 ]
	then
		echo -e "\e[32m【tester】：Make successfully\e[0m"
		return $SUCCESS
	else
		echo -e "\e[31m【tester】：[Warning] : Make failed\e[0m"
		return $FAIL
	fi
}

# Check if the specified process started successfully
# Parameter: [process id]
function check_background_process_start_status
{
	bp_pid=$1

	if ps | grep "$bp_pid[^[]" >/dev/null; then
    	return $SUCCESS
	else 
		return $FAIL
	fi
}

# Check what language the code is implemented in to execute different startup logic
function language_checking
{
	echo -e "\e[32m【tester】：Language checking......\e[0m"
	java_file_counter=`find ${LAB3_ABSOLUTE_PATH} -name "*.java" -o -name "*.jar" 2>/dev/null | wc -l`
	jar_file_counter=`find ${LAB3_ABSOLUTE_PATH} -name "kvstore2pcsystem.jar" 2>/dev/null | wc -l`
	c_file_counter=`find ${LAB3_ABSOLUTE_PATH} -name "*.c" 2>/dev/null | wc -l`
	cpp_file_counter=`find ${LAB3_ABSOLUTE_PATH} -name "*.cc" -o -name "*.cpp" -o -name "*.hpp" 2>/dev/null | wc -l`
	python_file_counter=`find ${LAB3_ABSOLUTE_PATH} -name "*.py" 2>/dev/null | wc -l`
	kvstore2pcsystem_py_file_counter=`find ${LAB3_ABSOLUTE_PATH} -name "kvstore2pcsystem.py" 2>/dev/null | wc -l`

	# 检查C/C++（优先）
	if [ $c_file_counter -gt 0 ] || [ $cpp_file_counter -gt 0 ]
	then
		echo -e "\e[32m【tester】：Language: [ C/C++ ]\e[0m"
		TEST_RESULT_ARR[0]="C/C++"
		return $C_OR_CPP
	fi

	# 检查Java
	if [ $java_file_counter -gt 0 ]
	then
		echo -e "\e[32m【tester】：Language: [ JAVA ]\e[0m"
		TEST_RESULT_ARR[0]="JAVA"
		if [ $jar_file_counter -eq 0 ]
		then
			echo -e "\e[31m【tester】：[Warning] : Have no file: kvstore2pcsystem.jar\e[0m"
			return $NO_JAR_FILE
		fi
		return $JAVA
	fi

	# 检查Python
	if [ $python_file_counter -gt 0 ]
	then
		echo -e "\e[32m【tester】：Language: [ PYTHON ]\e[0m"
		TEST_RESULT_ARR[0]="PYTHON"
		if [ $kvstore2pcsystem_py_file_counter -eq 0 ]
		then
			echo -e "\e[31m【tester】：Warning: [ Have no file: kvstore2pcsystem.py ]\e[0m"
			return $NO_KVSTORE2PCSYSTEM_PY_FILE
		fi
		return $PYTHON
	fi

	# 未知语言
	echo -e "\e[31m【tester】：Warning: [ UNKNOWN programing_language ]\e[0m"
	TEST_RESULT_ARR[0]="UNKNOWN"
	return $UNKNOWN_LANGUAGE
}

# Launch executable files in different language versions
# Parameter: [language code] [configuration file path]
function start_program
{
	case $1 in
    $C_OR_CPP)
        ${LAB3_ABSOLUTE_PATH}"/${EXECUTABLE_FILE_NAME}" --config_path $2 &
        ;;
    $JAVA)
        java -jar ${LAB3_ABSOLUTE_PATH}"/${EXECUTABLE_FILE_NAME}.jar" --config_path $2 &
        ;;
    $PYTHON)
        python3 ${LAB3_ABSOLUTE_PATH}"/${EXECUTABLE_FILE_NAME}.py" --config_path $2 &
        ;;
    *)
        ${LAB3_ABSOLUTE_PATH}"/${EXECUTABLE_FILE_NAME}" --config_path $2 &
        ;;
	esac
}

# Start the storage system robustly
# Parameter: [start mode] [language code] [configuration file index]
function run_kvstoresystem_robustly_2pc
{
	retval=$FAIL # parameter initialization

	if [[ $1 -eq $START_ONE_DATA_PROCESS_SPCECIFIC ]]; then
		check_background_process_start_status ${participants_pid[$3]}
		if [[ $? -eq $SUCCESS ]]; then
			echo "Run participant[$3] successfully"
			return $SUCCESS
		else
			for (( j=0; j<$START_RETYR_TIMES; j++ ))
			do
				start_program $2 ${participants_config_path[$3]}
				check_background_process_start_status $!
				retval=$?
				sleep0.5

				if [[ $retval -eq $SUCCESS ]]
				then
					echo "Run participant[$3] successfully"
					participants_pid[$3]=$!
					return $SUCCESS
				else
					echo "Run participant[$3]. Retry times: [$j]"
					continue
				fi
			done

			if [[ $retval -ne $SUCCESS ]]
			then
				echo "Run participant[$3] failed"
				return $FAIL
			fi
		fi
	fi

	
	for (( i=0; i<$START_RETYR_TIMES; i++ ))
	do
		start_program $2 ${coordinator_config_path}
		check_background_process_start_status $!
		retval=$?
		sleep 1

		if [[ $retval -eq $SUCCESS ]]
		then
			echo "Run coordinator successfully"
			coordinator_pid=$!
			break
		else
			sleep 1
			continue
		fi
	done

	if [ $retval -eq $SUCCESS ]
	then
		if [[ $1 -eq $START_COORDINATOR_ONLY ]]
		then
			return $SUCCESS
		fi

		for (( i=0; i<3; i++ ))
		do
			for (( j=0; j<$START_RETYR_TIMES; j++ ))
			do
				start_program $2 ${participants_config_path[i]}
				check_background_process_start_status $!
				retval=$?

				if [[ $retval -eq $SUCCESS ]]
				then
					echo "Run participant[$i] successfully"
					participants_pid[$i]=$!
					break
				else
					echo "Run participant[$i]. Retry times: [$j]"
					continue
				fi
			done

			if [[ $retval -ne $SUCCESS ]]
			then
				echo "Run participant[$i] failed"
				return $FAIL
			fi
		done
	else
		echo "Run coordinator failed"
		return $FAIL
	fi

	echo "Run ${EXECUTABLE_FILE_NAME} successfully"
	return $SUCCESS
}

# Start the storage system robustly
# Parameter: [start mode] [language code] [configuration file index]
function run_kvstoresystem_robustly_raft
{
	retval=$FAIL # parameter initialization

	if [[ $1 -eq $START_ONE_DATA_PROCESS_SPCECIFIC ]]; then
		check_background_process_start_status ${followers_pid[$3]}
		if [[ $? -eq $SUCCESS ]]; then
			echo "Run follower[$3] successfully"
			return $SUCCESS
		else
			for (( j=0; j<$START_RETYR_TIMES; j++ ))
			do
				start_program $2 ${followers_config_path[$3]}
				check_background_process_start_status $!
				retval=$?
				sleep 0.5

				if [[ $retval -eq $SUCCESS ]]
				then
					echo "Run follower[$3] successfully"
					followers_pid[$3]=$!
					return $SUCCESS
				else
					echo "Run follower[$3]. Retry times: [$j]"
					continue
				fi
			done

			if [[ $retval -ne $SUCCESS ]]
			then
				echo "Run follower[$3] failed"
				return $FAIL
			fi
		fi
	fi

	for (( i=0; i<3; i++ ))
	do
		for (( j=0; j<$START_RETYR_TIMES; j++ ))
		do
			start_program $2 ${followers_config_path[i]}
			check_background_process_start_status $!
			retval=$?

			if [[ $retval -eq $SUCCESS ]]
			then
				echo "Run follower[$i] successfully"
				followers_pid[$i]=$!
				break
			else
				echo "Run follower[$i]. Retry times: [$j]"
				continue
			fi
		done

		if [[ $retval -ne $SUCCESS ]]
		then
			echo "Run follower[$i] failed"
			return $FAIL
		fi
	done

	echo "Run ${EXECUTABLE_FILE_NAME} successfully"
	return $SUCCESS
}

# Start the storage system robustly
# Parameter: [start mode] [configuration file index]
function run_kvstoresystem_robustly
{
	retval=$FAIL # parameter initialization

	language_checking

	programing_language=$?

	# Do make if there's a makefile regardless of in what language the system is written.
	if [ -f ${LAB3_ABSOLUTE_PATH}/Makefile ] || [ -f ${LAB3_ABSOLUTE_PATH}/makefile ]
	then
		do_make
		if [ $? -eq $FAIL ]; then
			return $FAIL
		fi
	fi

	if [ $VERSION -eq 1 ]; then
		run_kvstoresystem_robustly_2pc $1 $programing_language $2
		return $?
	else
		run_kvstoresystem_robustly_raft $1 $programing_language $2
		return $?
	fi
}

# Kill the coordinator process and restart
function kill_and_restart_coordinator_robustly
{
	echo "Kill coordinator and then restart."

	kill -9 ${coordinator_pid}
	sleep 1
	run_kvstoresystem_robustly $START_COORDINATOR_ONLY

	retval=$?
	if [[ $retval -eq $SUCCESS ]]
	then
		return $SUCCESS
	else
		return $FAIL
	fi
}

# Kill the participant processes and coordinator process then restart
function kill_coordinator_and_all_participants
{
	kill -9 ${coordinator_pid}

	for (( i=0; i<3; i++ ))
	do
		kill -9 ${participants_pid[i]}
	done
}

function kill_coordinator
{
	kill -9 ${coordinator_pid}
}

function kill_one_of_participants
{
	kill -9 ${participants_pid[0]}
}

function kill_two_of_participants
{
	for (( i=1; i<3; i++ ))
	do
		kill -9 ${participants_pid[i]}
	done	
}

function kill_all_participants
{
	for (( i=0; i<3; i++ ))
	do
		kill -9 ${participants_pid[i]}
	done
}

function kill_one_of_followers
{
	kill -9 ${followers_pid[0]}
}

function kill_two_of_followers
{
	for (( i=1; i<3; i++ ))
	do
		kill -9 ${followers_pid[i]}
	done	
}

function kill_all_of_followers
{
	for (( i=0; i<3; i++ ))
	do
		kill -9 ${followers_pid[i]}
	done	
}

function kill_leader
{
	index=${LEADER_PORT: -1}
	kill -9 ${followers_pid[$index]}
}

# Restart the suspended service
function restart_kvstoresystem_if_down_abnormally
{
	if [ $VERSION -eq 1 ]; then
		if ! ps -p $coordinator_pid > /dev/null
		then
			kill_coordinator_and_all_participants
			sleep 1
			run_kvstoresystem_robustly $START_COORDINATOR_AND_ALL_PARTICIPANTS
			return
		fi

		for (( i=0; i<3; i++ ))
		do
			if ! ps -p ${participants_pid[i]} > /dev/null
			then
				run_kvstoresystem_robustly $START_ONE_DATA_PROCESS_SPCECIFIC $i
				sleep 1
			fi
		done
	else 
		for (( i=0; i<3; i++ ))
		do
			if ! ps -p ${followers_pid[i]} > /dev/null
			then
				run_kvstoresystem_robustly $START_ONE_DATA_PROCESS_SPCECIFIC $i
				sleep 1
			fi
		done
	fi
}

function parse_leader_infomation
{
	LEADER_IP=${1%%:*}
	LEADER_PORT=${1#*:}
}

# 智能RESP请求函数，支持自动重试和leader切换
function smart_resp_request
{
    # $1 命令类型（SET/GET/DEL）
    # $2~$n 其余参数（与原有send_set_command等一致）
    local cmd_type=$1
    shift
    local max_retry=10
    local retry_interval=2
    local try_count=0
    local leader_map=( [1]=0 [2]=1 [3]=2 )
    # 修正正则表达式，使其更宽松地匹配
    local moved_regex=".*\\+MOVED ([123]).*"
    local tryagain_regex=".*TRYAGAIN.*"
    local resp=""
    local leader_idx=0
    
    # 颜色代码
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
    # 构造请求内容
    case $cmd_type in
        SET)
            key_len=$1
            key=$2
            value_len=$3
            value=$4
            printf -v req "*3\r\n\$3\r\nSET\r\n\$${key_len}\r\n${key}\r\n\$${value_len}\r\n${value}\r\n"
            echo -e "${GREEN}【tester】：发送 SET $key $value 命令${RESET}"
            ;;
        GET)
            key_len=$1
            key=$2
            printf -v req "*2\r\n\$3\r\nGET\r\n\$${key_len}\r\n${key}\r\n"
            echo -e "${GREEN}【tester】：发送 GET $key 命令${RESET}"
            ;;
        DEL)
            if [ $# -eq 2 ]; then
                key1_len=$1
                key1=$2
                printf -v req "*2\r\n\$3\r\nDEL\r\n\$${key1_len}\r\n${key1}\r\n"
                echo -e "${GREEN}【tester】：发送 DEL $key1 命令${RESET}"
            else
                key1_len=$1
                key1=$2
                key2_len=$3
                key2=$4
                printf -v req "*3\r\n\$3\r\nDEL\r\n\$${key1_len}\r\n${key1}\r\n\$${key2_len}\r\n${key2}\r\n"
                echo -e "${GREEN}【tester】：发送 DEL $key1 $key2 命令${RESET}"
            fi
            ;;
        *)
            echo -e "${RED}【tester】：不支持的命令类型: $cmd_type${RESET}"
            return 1
            ;;
    esac
    
    while [ $try_count -lt $max_retry ]; do
        # 显示当前请求节点
        if [ $VERSION -eq 1 ]; then
            echo -e "${GREEN}【tester】：请求发送到: ${COORDINATOR_IP}:${COORDINATOR_PORT}${RESET}"
            resp=$(printf "$req" | nc -w ${NC_TIMEOUT} ${COORDINATOR_IP} ${COORDINATOR_PORT})
        else
            echo -e "${GREEN}【tester】：请求发送到: ${LEADER_IP}:${LEADER_PORT}${RESET}"
            resp=$(printf "$req" | nc -w ${NC_TIMEOUT} ${LEADER_IP} ${LEADER_PORT})
        fi
        
        # 调试输出实际收到的响应
        echo -e "${GREEN}【tester】：收到响应: ${resp}${RESET}"
        
        # 检查是否为TRYAGAIN (无论前缀是+还是-)
        if [[ $resp =~ $tryagain_regex ]]; then
            ((try_count++))
            echo -e "${RED}【tester】：【重试】收到TRYAGAIN响应，等待${retry_interval}秒后进行第${try_count}次重试 (最多${max_retry}次)${RESET}"
            sleep $retry_interval
            # 增加重试间隔，避免频繁重试
            retry_interval=$((retry_interval + 1))
            continue
        fi
        
        # 检查是否为MOVED <leader_id>
        if [[ $resp =~ $moved_regex ]]; then
            leader_id=${BASH_REMATCH[1]}
            leader_idx=${leader_map[$leader_id]}
            echo -e "${RED}【tester】：【重定向】收到MOVED响应，切换到leader ${leader_id} (${follower_ip[$leader_idx]}:${follower_port[$leader_idx]})${RESET}"
            LEADER_IP=${follower_ip[$leader_idx]}
            LEADER_PORT=${follower_port[$leader_idx]}
            ((try_count++))
            sleep $retry_interval
            continue
        fi
        
        # 如果不需要重试，跳出循环
        echo -e "${GREEN}【tester】：请求成功完成，无需重试${RESET}"
        break
    done
    
    # 检查是否达到最大重试次数
    if [ $try_count -eq $max_retry ]; then
        echo -e "${RED}【tester】：警告: 达到最大重试次数 ${max_retry}，测试项可能失败${RESET}"
    fi
    
    # 设置返回值
    case $cmd_type in
        SET)
            set_result="$resp"
            ;;
        GET)
            get_result="$resp"
            ;;
        DEL)
            if [ $# -eq 2 ]; then
                del_1_result="$resp"
            else
                del_2_result="$resp"
            fi
            ;;
    esac
}

function send_set_command { smart_resp_request SET "$@"; }
function send_get_command { smart_resp_request GET "$@"; }
function send_del_command_1 { smart_resp_request DEL "$@"; }
function send_del_command_2 { smart_resp_request DEL "$@"; }

# ######################## basic version lv1 ########################

function set_tag
{
    local GREEN="\e[32m"
    local RESET="\e[0m"
	echo -e "${GREEN}【tester】：                                       | |                                   ${RESET}"
	echo -e "${GREEN}【tester】：                                       | |                                   ${RESET}"
	echo -e "${GREEN}【tester】：                                       \|/                                   ${RESET}"
}

printf -v standard_error "%s\r" "-ERROR"
printf -v standard_ok "+OK\r"
printf -v standard_nil "*1\r\n\$3\r\nnil\r"

standard_item1=""
function test_item1
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------- Test item 1 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 1. Test point: Run kvstore2pcsystem.${RESET}"

	run_kvstoresystem_robustly $START_COORDINATOR_AND_ALL_PARTICIPANTS

	retval=$?
	if [[ $retval -eq $SUCCESS ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 1 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 1 ============================${RESET}"
		return $FAILED
	fi
}

standard_item2="$standard_ok"
function test_item2
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------- Test item 2 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 2. Test point: Set key to hold string value.${RESET}"

	send_set_command 9 item2_key 11 item2_value

	echo -e "${GREEN}【tester】：item set set_result: ${set_result}${RESET}"
	if [[ $set_result = $standard_item2 ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 2 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 2 ============================${RESET}"
		return $FAILED
	fi
}


printf -v standard_item3 "*1\r\n\$11\r\nitem3_value\r"
function test_item3
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------- Test item 3 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 3. Test point: Get the value of key.${RESET}"

	send_set_command 9 item3_key 11 item3_value
	sleep 1
	if [ $VERSION -eq 1 ]; then
		kill_and_restart_coordinator_robustly
	else 
		kill_leader
		sleep 5
		restart_kvstoresystem_if_down_abnormally
		sleep 5
	fi
	send_get_command 9 item3_key
	echo -e "${GREEN}【tester】：get_result: ${get_result}${RESET}"
	if [[ $get_result = $standard_item3 ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 3 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 3 ============================${RESET}"
		return $FAILED
	fi
}


standard_item4="$standard_nil"
function test_item4
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------- Test item 4 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 4. Test point: Return nil if the key does no exist.${RESET}"

	send_get_command 9 item4_key

	if [[ $get_result = $standard_item4 ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 4 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 4 ============================${RESET}"
		return $FAILED
	fi

}


printf -v standard_item5 ":2\r"
function test_item5
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------ Test item 5 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 5. Test point: If the DEL command executed, return the number of keys that were removed.${RESET}"

	send_set_command 11 item5_key_1 13 item5_value_1
	send_set_command 11 item5_key_2 13 item5_value_2
	send_del_command_2 11 item5_key_1 11 item5_key_2

	if [[ $del_2_result = $standard_item5 ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 5 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 5 ============================${RESET}"
		return $FAILED
	fi
}


printf -v standard_item6 "*1\r\n\$15\r\nitem6_value_new\r"
function test_item6
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------- Test item 6 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 6. Test point: When associating a new value to an existing key, it should overwrite the value of the existing entry,${RESET}"

	send_set_command 9 item6_key 11 item6_value
	send_set_command 9 item6_key 15 item6_value_new
	send_get_command 9 item6_key

	if [[ $get_result = $standard_item6 ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 6 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 6 ============================${RESET}"
		return $FAILED
	fi
}


standard_item7="$standard_nil"
function test_item7
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------- Test item 7 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 7. Test point: Correctness testing of DEL command.${RESET}"

	send_set_command 9 item7_key 11 item7_value
	send_del_command_1 9 item7_key
	send_get_command 9 item7_key

	if [[ $get_result = $standard_item7 ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 7 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 7 ============================${RESET}"
		return $FAILED
	fi
}


########################## basic version lv2 ########################

printf -v standard_item8 "*1\r\n\$17\r\nitem8_key_value_3\r"
function test_item8
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------- Test item 8 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 8. Test point: Kill one of the store processes.${RESET}"

	send_set_command 9 item8_key 17 item8_key_value_1
	send_set_command 9 item8_key 17 item8_key_value_2
	sleep 10
	if [ $VERSION -eq 1 ]; then
		kill_one_of_participants
	else 
		kill_one_of_followers
		sleep 10
	fi
	send_set_command 9 item8_key 17 item8_key_value_3
	send_get_command 9 item8_key

	if [[ $get_result = $standard_item8 ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 8 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 8 ============================${RESET}"
		return $FAILED
	fi

}


standard_item9="$standard_error"
function test_item9
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------- Test item 9 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 9. Test point: Kill all storage proccesses.${RESET}"

	send_set_command 9 item9_key 17 item9_key_value_1
	send_set_command 9 item9_key 17 item9_key_value_2
	if [ $VERSION -eq 1 ]; then
		kill_all_participants
	else 
		return $PASSED
	fi
	

	send_get_command 9 item9_key

	if [[ $get_result =~ $standard_item9 ]]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 9 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 9 ============================${RESET}"
		return $FAILED
	fi

}

########################## basic version lv3 ########################

printf -v standard_get_item10 "*1\r\n\$20\r\nitem10_key_2_value_2\r"
printf -v standard_del_item10 ":2\r"
function test_item10
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	set_tag
	echo -e "${GREEN}【tester】：------------------------------------ Test item 10 -------------------------------------${RESET}"
	echo -e "${GREEN}【tester】：Test item 10. Test point: extreme version test, Kill two storage nodes and restart them before testing GET and DEL.${RESET}"

	restart_kvstoresystem_if_down_abnormally

	send_set_command 12 item10_key_1 20 item10_key_1_value_1
	send_set_command 12 item10_key_2 20 item10_key_2_value_2
	if [ $VERSION -eq 1 ]; then
		kill_two_of_participants
	else	
		kill_two_of_followers
	fi
	sleep 10
	restart_kvstoresystem_if_down_abnormally
	sleep 30

	send_get_command 12 item10_key_2

	get_success=0

	if [[ $get_result = $standard_get_item10 ]]
	then
		get_success=1
	fi

	send_del_command_2 12 item10_key_1 12 item10_key_2
	
	if [ $del_2_result = $standard_del_item10 ] && [ $get_success -eq 1 ]
	then
		echo -e "${GREEN}【tester】：============================ [\e[32mPASSED\e[0m] : Test item 10 ============================${RESET}"
		return $PASSED
	else
		echo -e "${RED}【tester】：============================ [\e[31mFAILED\e[0m] : Test item 10 ============================${RESET}"
		return $FAILED
	fi
}

# Start all test points
function cloud_roll_up
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local RESET="\e[0m"
    
	echo -e "${GREEN}【tester】：---------------------------------- Global test start ----------------------------------${RESET}"
	test_item1
	TEST_RESULT_ARR[1]=$?
	if [[ ${TEST_RESULT_ARR[1]} -eq $FAILED ]]
	then
		echo -e "${RED}【tester】：---------------------------------- Start system failed. Global test done ----------------------------------${RESET}"
		return
	fi
	test_item2
	TEST_RESULT_ARR[2]=$?
	test_item3
	TEST_RESULT_ARR[3]=$?
	test_item4
	TEST_RESULT_ARR[4]=$?
	test_item5
	TEST_RESULT_ARR[5]=$?
	test_item6
	TEST_RESULT_ARR[6]=$?
	test_item7
	TEST_RESULT_ARR[7]=$?
	test_item8
	TEST_RESULT_ARR[8]=$?
	test_item9
	TEST_RESULT_ARR[9]=$?
	test_item10
	TEST_RESULT_ARR[10]=$?

	echo -e "${GREEN}【tester】：---------------------------------- Global test done -----------------------------------${RESET}"
}

# Clear testing environment
function clean_up
{
	if [ $VERSION -eq 1 ]; then
		kill_coordinator_and_all_participants
	else
		kill_all_of_followers
	fi
	remove_virtual_nics
	clean_up_config_files
}

# Show test results
function show_test_result
{
    local GREEN="\e[32m"
    local RED="\e[31m"
    local YELLOW="\e[33m"
    local RESET="\e[0m"
    
	echo -e "${GREEN}【tester】：Language: [ ${TEST_RESULT_ARR[0]} ]${RESET}"
	echo -e "${GREEN}【tester】：VERSION: [ ${VERSION} ]${RESET}"
	echo -n > $LAB3_TEST_RESULT_SAVE_PATH/lab3_test_result.csv
	echo -e "${GREEN}【tester】：---------------------------------- Passing situation ----------------------------------${RESET}"
	for (( i=1; i<11; i++ ))
	do
		if [[ ${TEST_RESULT_ARR[i]} -eq $PASSED ]]
		then
			echo -e "${GREEN}【tester】：Test items ${i} [ \e[32mPASSED\e[0m ]${RESET}"
			echo -e "PASSED \c" >> $LAB3_TEST_RESULT_SAVE_PATH/lab3_test_result.csv
		else
			echo -e "${RED}【tester】：Test items ${i} [ \e[31mFAILED\e[0m ]${RESET}"
			echo -e "FAILED \c" >> $LAB3_TEST_RESULT_SAVE_PATH/lab3_test_result.csv
		fi
	done

	# The logic of calculating scores: for the first 7 tests, each item receives 2 points. 
	# If all 7 items pass, 15 points will be given, the last 3 items receive 1 point per item;.
	# If the final total score is 18 points and the implemented version is advanced version, 20 points will be given.
	total_score=0
	for (( i=1; i<8; i++ ))
	do
		if [[ ${TEST_RESULT_ARR[i]} -eq $PASSED ]]
		then
			total_score=`expr $total_score + 2`
		fi
	done

	if [[ $total_score -eq 14 ]]
	then
		total_score=15
	fi

	for (( i=8; i<11; i++ ))
	do
		if [[ ${TEST_RESULT_ARR[i]} -eq $PASSED ]]
		then
			total_score=`expr $total_score + 1`
		fi
	done

	if [ $VERSION -eq 2 ]
	then
		total_score=`expr $total_score + 2`
	fi

	echo -e  "${GREEN}【tester】：--------------------------------- Total score: [ ${YELLOW}${total_score}${GREEN} ] ----------------------------------${RESET}"
}

# Prepare testing environment
function prepare_test_env
{
	set_executable_file_name
	generate_config_files
	init_network_env
}

############################### End of testing using function definitions ##################################

############################### Main function execution for testing ########################################

prepare_test_env
cloud_roll_up
clean_up
show_test_result
